
# Prints local header
function header(){
    printf "\n"
    message 0 "$1"
}

# Prints padded message
message() {
	local initialpadding=$1
	local message=$2
	pad=$(printf '%0.1s' " "{1..80})
	printf "%*.*s%s\n" 0 $initialpadding "$pad" "$message"
}

# Calculates padding
padding(){
    if [ -z $1 ]; then
        echo 2;
        return 0;
    fi
    echo $(( 2 + $1 ))
}

# Convert version to number in order to sort it.
# Because there are no -V in mac sort
# https://stackoverflow.com/questions/16989598/bash-comparing-version-numbers
version() {
    echo "$@" | awk -F. '{ printf("%03d%03d%03d\n", $1,$2,$3); }'
}

# Installs brew
install_brew() {
    if [[ -z "${ISBREW}" ]]; then
        message $PAD "$(printf "# Installing Brew (%s) first\n" "https://brew.sh/")"
    elif [ "${1}" == "--upgrade" ]; then
        message $PAD "$(printf "# Upgrading Brew\n")"
    fi

    if [ "${1}" == "--upgrade" ] || [ -z "${ISBREW}" ] ; then
        /usr/bin/ruby -e "$(curl -fsSL $BREW_URL)"
    fi
}

install_brew_bundle() {
  brew bundle
}


# General Setup for .zshrc
# Adding pathinfo to point back to this repo directory
install_zshrc() {
    local URL=https://github.com/butuzov/dots
    local ZSHRC=~/.zshrc

    if [[ ! -f $ZSHRC ]]; then
        touch $ZSHRC
    fi

    local padding=$(padding 0)
    local zshrc=$(cat ~/.zshrc | grep "$URL")

    if [[ ! -f $ZSHRC || -z $zshrc ]]; then

        printf "\n# Next content added by \`./activate.sh\` from the" >> $ZSHRC
        printf "\n# repository %s \n" $URL >> $ZSHRC
        printf "\nexport DOTS_PATH=\"%s\"" $NWD >> $ZSHRC
        printf "\nsource \"\${DOTS_PATH}/.zshrc\"\n" >> $ZSHRC
        printf "\n# End of the autogenerated record \n" $URL >> $ZSHRC

        message="$(echo "changes made to .zshrc")"

    else
        message="$(echo ".zshrc doesn't require change")"
    fi

    message $padding "${message}"
}


# Installs symbolic link to file in out repository
# Used to install multiple dotfiles from out repository
install_dot() {
    TARGET=$1

    local padding=$(padding $2)
    local message

    local CREATE_LINK=0
    local LINK_MOVED=0

    if [[ -f ~/$TARGET && ! -h ~/$TARGET  ]]; then
        LINK_MOVED=1
        CREATE_LINK=1
    elif [[ -h ~/$TARGET && $(readlink ~/$TARGET) != $(pwd)/$TARGET ]]; then
        LINK_MOVED=1
        CREATE_LINK=1
    elif [[ ! -f ~/$TARGET ]]; then
        CREATE_LINK=1
    else
        message="$(printf "* %s already installed\n" $TARGET)"
        message $padding "${message}"
        return 0
    fi

    # Actually moving files
    if (( $LINK_MOVED == 1)); then
        message="$(printf "* %s : backuped" $TARGET)"
        message $padding "${message}"
        mv ~/$TARGET{,-backup_$(date +%Y-%m-%d)}
    fi

    if (( $CREATE_LINK == 1)); then
        message="$(printf "* %s : link created" $TARGET)"
        message $padding "${message}"
        ln -s "$(pwd)/$TARGET" ~/$TARGET
    fi
}

# Install from git repository
install_git_repository() {
    local DIRECTORY=$2
    local REPOSITORY=$1
    if [[ ! -d "${DIRECTORY}" ]]; then
      git clone --depth 20 $REPOSITORY "${DIRECTORY}"  > /dev/null
    fi
}

# Obtain last release and checkout it.
function checkout_last_release(){

    local DIRECTORY=$1
    local VERSION=$(git tag -l | \
        git tag -l | \
        grep "\." | \
        awk -F'.' '{printf("%03d%03d%03d:%s\n", $1,$2,$3, $0);}' | \
        sort -nr | \
        head -n 1 | \
        awk -F':' '{print $2}'
    )

    git checkout "tags/${VERSION}" > /dev/null 2>&1

    cd "${NWD}"
}
